<!DOCTYPE html>
<html>
<head>
    <title>Three.js æ›¸æœ¬å¼å¹¾ä½•æ’ç‰ˆèˆ‡äº’å‹•</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let scene, camera, renderer, controls, gui, raycaster, mouse;
        let objectGroup = new THREE.Group(); // æ‰€æœ‰å¹¾ä½•åœ–å½¢å®¹å™¨

        // è¦–è¦ºåƒæ•¸è¨­å®šç‰©ä»¶
        const settings = {
            gridSize: 10,      // æ¯è¡Œ/åˆ—çš„åœ–å½¢æ•¸é‡ (ä¾‹å¦‚ 10x10)
            spacing: 3.0,      // åœ–å½¢é–“è·
            shapeSize: 0.5,    // åœ–å½¢åŸºç¤å¤§å°
            maxJumpHeight: 2.0, // æ»‘é¼ äº’å‹•æ™‚æœ€å¤§è·³èµ·é«˜åº¦
            hoverRadius: 1.5,   // æ»‘é¼ äº’å‹•å½±éŸ¿åŠå¾‘
            lineColor: '#00ffff',
            driftSpeed: 0.005,  // å·¦å³é£„ç§»é€Ÿåº¦
            cameraZ: 25,       // æ”å½±æ©Ÿåˆå§‹ä½ç½®
            updateShapes: () => createAllShapes() // æ›´æ–°çµæ§‹æŒ‰éˆ•
        };

        const shapes = []; // ç”¨æ–¼å„²å­˜æ‰€æœ‰å¹¾ä½•å½¢ç‹€åŠå…¶åˆå§‹ä½ç½®ã€æè³ª
        const shapeTypes = ['star', 'square', 'circle', 'triangle']; // å¹¾ä½•å½¢ç‹€åˆ—è¡¨
        
        // --- åˆå§‹åŒ–å‡½å¼ ---
        function init() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = settings.cameraZ;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height); 
            document.body.appendChild(renderer.domElement);

            // è¨­ç½® Raycasting (ç”¨æ–¼æ»‘é¼ äº’å‹•)
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('mousemove', onMouseMove, false);
            
            // å‰µå»ºæ‰€æœ‰å¹¾ä½•å½¢ç‹€
            createAllShapes();
            scene.add(objectGroup);

            // è¨­ç½®æ»‘é¼ æ§åˆ¶ (OrbitControls)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // è¨­ç½® GUI
            setupGUI();

            window.addEventListener('resize', onWindowResize, false);
        }

        // --- å¹¾ä½•é«”ç”Ÿæˆå·¥å…·å‡½å¼ ---

        function createStarGeometry(size) {
            const vertices = [];
            const outerR = size;
            const innerR = size * 0.5;
            const points = 5;
            const step = Math.PI / points;

            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerR : innerR;
                const angle = i * step + Math.PI / 2;
                vertices.push(radius * Math.cos(angle), radius * Math.sin(angle), 0);
            }
            vertices.push(vertices[0], vertices[1], vertices[2]);
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            return geometry;
        }

        function createSquareGeometry(size) {
            const vertices = new Float32Array([
                -size,  size, 0, 
                -size, -size, 0, 
                 size, -size, 0, 
                 size,  size, 0, 
                -size,  size, 0  
            ]);
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            return geometry;
        }

        function createCircleGeometry(size, segments = 32) {
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                points.push(new THREE.Vector3(size * Math.cos(angle), size * Math.sin(angle), 0));
            }
            // ä½¿ç”¨ LineLoop æˆ– Line æœƒæ ¹æ“šéœ€æ±‚èª¿æ•´ï¼Œé€™è£¡ç”¨ Line ä¸”æœ€å¾Œé–‰åˆ
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            return geometry;
        }

        function createTriangleGeometry(size) {
            const vertices = new Float32Array([
                 0,  size, 0, 
                -size, -size, 0, 
                 size, -size, 0, 
                 0,  size, 0 
            ]);
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            return geometry;
        }

        function getGeometry(type, size) {
            switch(type) {
                case 'star': return createStarGeometry(size);
                case 'square': return createSquareGeometry(size);
                case 'circle': return createCircleGeometry(size);
                case 'triangle': return createTriangleGeometry(size);
                default: return createSquareGeometry(size);
            }
        }

        // --- å‰µå»ºæ‰€æœ‰å¹¾ä½•å½¢ç‹€ä¸¦æ’ç‰ˆ ---
        function createAllShapes() {
            // æ¸…ç†èˆŠçš„ç¾¤çµ„
            objectGroup.children.forEach(child => child.geometry.dispose());
            objectGroup.clear();
            shapes.length = 0; // æ¸…ç©º shapes æ•¸çµ„

            const material = new THREE.LineBasicMaterial({ color: new THREE.Color(settings.lineColor) });
            const halfGrid = settings.gridSize * settings.spacing / 2;

            for (let i = 0; i < settings.gridSize; i++) {
                for (let j = 0; j < settings.gridSize; j++) {
                    // éš¨æ©Ÿé¸æ“‡å½¢ç‹€
                    const type = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];
                    const geometry = getGeometry(type, settings.shapeSize);

                    const line = new THREE.Line(geometry, material);
                    
                    // åƒæ›¸ä¸­æ–‡å­—ä¸€æ¨£æ’æ’ç«™å¥½ (çŸ©å½¢ç¶²æ ¼)
                    const initialX = (i * settings.spacing) - halfGrid + (settings.spacing / 2);
                    const initialY = (j * settings.spacing) - halfGrid + (settings.spacing / 2);
                    
                    line.position.set(initialX, initialY, 0);

                    // å„²å­˜å½¢ç‹€çš„åŸå§‹æ•¸æ“š
                    shapes.push({
                        mesh: line,
                        initialPos: new THREE.Vector3(initialX, initialY, 0),
                        type: type,
                        row: i, // ç”¨æ–¼å·¦å³é£„ç§»
                        hoverTime: 0 // ç”¨æ–¼è·³èµ·å‹•ç•«
                    });
                    
                    objectGroup.add(line);
                }
            }
        }

        // --- æ»‘é¼ äº’å‹•å‡½å¼ ---
        function onMouseMove(event) {
            // å°‡æ»‘é¼ åº§æ¨™è½‰æ›ç‚ºæ¨™æº–åŒ–è¨­å‚™åº§æ¨™ (NDC) [-1 to 1]
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function updateHoverEffect(time) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objectGroup.children);
            let closestIntersect = null;

            if (intersects.length > 0) {
                // æ‰¾åˆ°æœ€è¿‘çš„äº¤é»
                closestIntersect = intersects[0];
            }

            shapes.forEach(shape => {
                const mesh = shape.mesh;
                const pos = mesh.position;
                
                // 1. å·¦å³é£„ç§» (åƒæ–‡å­—ä¸€æ¨£)
                const driftAmount = Math.sin(time * settings.driftSpeed + shape.row) * 0.5;
                // è®“ä¸€åŠå‘å·¦é£„ï¼Œä¸€åŠå‘å³é£„ (æ ¹æ“šè¡Œæ•¸ row)
                if (shape.row % 2 === 0) {
                    pos.x = shape.initialPos.x + driftAmount;
                } else {
                    pos.x = shape.initialPos.x - driftAmount;
                }
                pos.y = shape.initialPos.y; // Y è»¸ä¸é£„ç§»

                // 2. æ»‘é¼ è·³èµ·æ•ˆæœ (åƒè¢«æ‰“äº‚ä¸€æ¨£)
                let distance = Infinity;
                if (closestIntersect) {
                    // è¨ˆç®—åœ–å½¢ä¸­å¿ƒèˆ‡æ»‘é¼ å…‰æ¨™åœ¨ Z=0 å¹³é¢çš„è·é›¢
                    distance = pos.distanceTo(closestIntersect.point);
                }

                if (distance < settings.hoverRadius) {
                    // å¦‚æœåœ¨å½±éŸ¿ç¯„åœå…§ï¼Œå¢åŠ  hoverTime
                    shape.hoverTime += 0.05;
                } else {
                    // å¦‚æœä¸åœ¨å½±éŸ¿ç¯„åœå…§ï¼Œæ¸›å°‘ hoverTime (æ¢å¾©)
                    shape.hoverTime = Math.max(0, shape.hoverTime - 0.03);
                }

                // æ ¹æ“š hoverTime è¨­ç½® Z è»¸ä½ç½® (è·³èµ·)
                // ä½¿ç”¨ Math.sin å‡½æ•¸è®“è·³èµ·æ•ˆæœæ›´å¹³æ»‘å’Œå…·æœ‰å½ˆæ€§
                const zOffset = Math.sin(shape.hoverTime) * settings.maxJumpHeight;
                // åƒ…ç•¶ hoverTime > 0.01 æ™‚æ‰è¨­ç½® Z è»¸ï¼Œé¿å…å¾®å°æŠ–å‹•
                if (shape.hoverTime > 0.01) {
                    pos.z = zOffset;
                } else {
                    pos.z = 0; // æ¢å¾©åˆ°å¹³é¢
                }
                
                // é¡å¤–æ—‹è½‰ (è®“è·³èµ·çš„åœ–å½¢çœ‹èµ·ä¾†æ›´è¢«æ‰“äº‚)
                mesh.rotation.z = zOffset * 0.5;
            });
        }

        // --- GUI è¨­ç½®å‡½å¼ ---
        function setupGUI() {
            gui = new dat.GUI();

            const layoutFolder = gui.addFolder('å¹¾ä½•æ’ç‰ˆèˆ‡å¤§å°');
            layoutFolder.add(settings, 'gridSize', 5, 20).step(1).name('ç¶²æ ¼å¤§å° (N x N)');
            layoutFolder.add(settings, 'spacing', 1.0, 5.0).step(0.1).name('åœ–å½¢é–“è·');
            layoutFolder.add(settings, 'shapeSize', 0.1, 1.5).step(0.05).name('åœ–å½¢å¤§å°');
            layoutFolder.addColor(settings, 'lineColor').name('ç·šæ¢é¡è‰²').onChange(() => {
                const newColor = new THREE.Color(settings.lineColor);
                shapes.forEach(s => s.mesh.material.color.set(newColor));
            });
            layoutFolder.add(settings, 'updateShapes').name('ğŸš© æ›´æ–°æ’ç‰ˆçµæ§‹');
            layoutFolder.open();

            const animFolder = gui.addFolder('å‹•ç•«èˆ‡äº’å‹•');
            animFolder.add(settings, 'driftSpeed', 0.0001, 0.02).step(0.0001).name('é£„ç§»é€Ÿåº¦');
            animFolder.add(settings, 'maxJumpHeight', 0.5, 5.0).step(0.1).name('æœ€å¤§è·³èµ·é«˜åº¦');
            animFolder.add(settings, 'hoverRadius', 0.5, 5.0).step(0.1).name('æ»‘é¼ å½±éŸ¿åŠå¾‘');
            animFolder.open();
        }

        // --- è¦–çª—èª¿æ•´èˆ‡å‹•ç•«å¾ªç’°å‡½å¼ ---

        function onWindowResize() {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix(); 
            renderer.setSize(newWidth, newHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);

            // æ›´æ–°æ»‘é¼ æ§åˆ¶
            controls.update(); 

            // æ›´æ–°å·¦å³é£„ç§»å’Œæ»‘é¼ äº’å‹•æ•ˆæœ
            updateHoverEffect(time);

            // æ¸²æŸ“å ´æ™¯
            renderer.render(scene, camera);
        }

        // å•Ÿå‹•ç¨‹å¼
        init();
        animate(0); 
    </script>
</body>
</html>